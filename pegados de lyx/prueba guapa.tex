%% LyX 2.0.6 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{setspace}
\doublespacing
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{pdftitle={Iptables vs Nftables},
 pdfauthor={José María Caballero Alba}}
\begin{document}

\title{Iptables vs Nftables.}


\author{José María Caballero Alba}

\maketitle
\tableofcontents{}


\section{Prologo}

Es interesante comparar el uso de iptables de manera practica y compararlo
con lo que seria la traducción a nftables, tenemos que tener en cuenta
que algunas opciones de iptables no están disponibles en nftables
por estar aún en desarrollo y viceversa.

\pagebreak{}


\section{Diferencias principales}
\begin{itemize}
\item La primera y mas distinguible es la sintaxis, en iptables, las flags
van precedidas de dos guiones o uno (-p tcp) en nftables usa una sintaxis
mas limpia, inspirada en tcpdump.
\item Las tablas y las cadenas son totalmente configurables en nftables,
contrariamente a iptables, que solo ofrece un set definido de tablas
y cadenas, nftables permite crear cadenas y tablas propias con sus
correspondientes configuraciones en función de lo que necesites.
\item No hay distinción entre objetivos y targets, en nftables tenemos expresiones
que son instrucciones para construir nuestras reglas. Esto es muy
diferente en iptables que requiere sintaxis de objetivos y targets
para usar protocolos.
\item Se pueden especificar varias acciones en una sola linea en nftables,
con iptables solo podemos especificar una.
\item Los contadores en iptables son establecidos de manera fija para cada
tabla y reglas, en nftables se puede establecer de manera opciones
estos contadores.
\item Infraestructura de manera genérica en lo sets en nftables, esto permite
configuraciones avanzadas como diccionarios, mapas.
\item Actualizar el kernel es una tarea que consume mucho tiempo, especialmente
si quieres mantener mas de un firewall en tu red. Los distribuidores
normalmente usan versiones antiguas del kernel de linux por razones
de estabilidad. Con la nueva maquina de estados de nftables no es
necesario actualizar el kernel para un nuevo protocolo, simplemente
es necesario actualizar la utilidad nft.
\item No es necesario el uso de guiones (-) o dobles guiones (--) para el
uso de las banderas.
\end{itemize}

\section{Configurando tablas }


\subsection{Creando tablas Iptables}

Iptables cuenta con 5 tablas (raw, filter, nat, mangle, security)
que son zonas en las que una cadena de puede aplicar.

Estas tablas son por defecto, que ya vienen con una serie de cadenas
por defecto (input, output, postrouting, prerouting etc). Estas vienen
sin reglas.

Para configurar las tablas tenemos el siguiente formato:

iptables -t {[}tabla{]} {[}-AIRELNPDZ{]} {[}CADENA{]} {[}PARAMETROS{]}
{[}-j ACCION{]}

En iptables para poder configurar un tabla, tenemos que usar por obligación
una de las cadenas, ya que no nos deja atacar una tabla solamente.

Para hacer un ejemplo sencillo:
\begin{itemize}
\item iptables -t filter -P INPUT -j drop
\end{itemize}
Esto estará aplicando la politica por defecto de rechazar los paquetes
de la cadena input.

Debemos de tener en cuenta, que para configurar una tabla en iptables
no obliga configurar también al menos una de las cadenas de esa tabla.


\subsection{Creando tablas Nftables}

En nftables seguimos contando con las mismas tablas que en iptables,
que siguen siendo las zonas en las que podemos crear cadenas y después
crear reglas en ellas. La diferencia principal y mas notable respecto
a iptables que podemos crear nuestras tablas y además no nos obliga
a configurar una cadena a la hora de crearla. Para configurar una
tabla en nftables tenemos el siguiente formato:

nft create table {[}ip{]} nombre\_tabla

Como vemos tenemos un formato mas sencillo que además podemos crear
la tabla solamente sin configurar nada y decidir si pertenece ( o
no) a la familia ip.

Un ejemplo muy sencillo de crear una tabla:
\begin{itemize}
\item nft create table filter
\end{itemize}
Esto creará la tabla de tipo ip (por defecto, no lo hemos especificado)
filter, la cual no contiene cadenas. Solo contiene la definición de
la tabla en si misma.


\subsection{Listando tablas en Iptables}

En iptables podemos mostrar listar las tablas, para especificar una
en concreto podemos usar el parametro -t tabla. Para mostrar la tabla
(junto con sus cadenas y sus reglas, no solo los nombres de las tablas)
basta con:
\begin{itemize}
\item iptables -L
\end{itemize}
Esto no mostrara el contenido de la tabla, con sus cadenas y sus reglas,
no nos esta ``listando'' las tablas. Al no usar el parametro -t,
se muestra por defecto la tabla filter.


\subsection{Listando tablas en Nftables}

Al contrario que en iptables, nftables si que nos deja listar las
tablas y no nos obliga a ver su contenido. Para listar las tablas
simplemente podemos hacer esto:
\begin{itemize}
\item nft list tables
\end{itemize}
Debemos fijarnos que tables, termina en s, es decir plural, por lo
tanto nos esta listando los nombres de las tablas.

Por el contrario, si queremos listar solo una tabla y ya si que nos
enseña el contendido de esta tabla con sus cadenas y reglas, bastaría
con:
\begin{itemize}
\item nft list table nombre\_tabla
\end{itemize}
Esto no mostraría exactamente el mismo contendido que en iptables. 

Ej de capturas de pantalla:

iptables -t filter -L:

\includegraphics{pegado2}

nft list tables:

\includegraphics{pegado3}

Como vemos, en nftables tenemos la opción de listar solamente las
tablas y de listar al modo de iptables para una tabla en concreto.


\subsection{Borrando tablas en iptables}

En iptables no podemos borrar una tabla, podemos vaciar o sus cadenas,
o eliminar las reglas, pero las tablas siguen existiendo.


\subsection{Borrando tablas nftables}

En nftables si que se nos permite borrar una tabla, con esto borraríamos
la tabla, sus cadenas y sus reglas. El formato a usar seria el siguiente:
\begin{itemize}
\item nft delete table nombre\_tabla
\end{itemize}
Y no es necesario nada mas, con esto podemos borrar una tabla en nftables,
cosa que con iptables no podíamos.


\subsection{Vaciado de tables en iptables}

En iptables para vaciar (flush) las tablas (no podemos borrar las
cadenas, solo podemos vaciarlas) de manera general podriamos hacer:
\begin{itemize}
\item iptables -t filter --flush
\end{itemize}
Esto nos vaciaría todas las todas las cadenas de la tabla filter.
Si omitimos el parametro -t, nos vaciaria todas las cadenas de todas
las tablas.


\subsection{Vaciado de tablas en nftables.}

En nftables si que podemos vaciar tablas de manera completa, es decir,
podemos elimintar todas la reglas y las cadenas que las contienen:
\begin{itemize}
\item nft flush table nombre\_tabla
\end{itemize}
Es nos eliminaría las cadenas y las reglas de la tabla especificada.


\section{Configurando cadenas}


\subsection{Añadiendo cadenas en Iptables}

En iptables ya tenemos por defecto cadenas asociadas a nuestras tablas,
aunque se pueden añadir cadenas personalizadas, por ej, por defecto
la tabla filter tiene las cadenas de serie input outputy forward,
así que si queremos añadir una cadena nueva a la tabla filter podemos
hacerlo con la opcion -N de esta manera:
\begin{itemize}
\item iptables {[}-t tabla{]} -N nombre\_cadena
\end{itemize}
Para la tabla filter:
\begin{itemize}
\item iptables -t filter -N nueva\_cadena 
\end{itemize}
O también:
\begin{itemize}
\item iptables -N nueva\_cadena
\end{itemize}
Recordemos que en iptables la tabla por defecto es filter

\includegraphics{pegado4}


\subsection{Añadiendo tablas en nftables}

En nftables no tenemos cadenas por defecto dentro de nuestras tablas,
pero tenemos la posibilidad de añadir las cadena de tipo base (input,
output, forward, postrouting, prerouting) o crear cadenas personalizadas,
con el siguiente formato:
\begin{itemize}
\item nft add chain ip nombre\_tabla nombre\_cadena \{type filter hook {[}cadena\_base{]}
priority 0 \textbackslash{}; \}
\end{itemize}
Y un ejemplo:
\begin{itemize}
\item nft add chain ip filter postrouting \{ type filter hook postrouting
priority 0 \textbackslash{}; \}
\end{itemize}
Esto no crearía la cadena de tipo base postrouting dentro de la tabla
filter, si queremos tener cadenas personalizadas, simplemente hacemos:
\begin{itemize}
\item nft add chain nombre\_tabla nombre\_cadena
\end{itemize}
Ejemplo:
\begin{itemize}
\item nft add chain filter input
\end{itemize}
Esto no crea una cadena personalizada dentro de la tabla filter. Lo
podemos apreciar en la siguiente captura:

\includegraphics{pegado5}


\subsection{Borrando cadenas en iptables}

En iptables no podemos borrar las cadenas por defecto pero si las
personalizadas, tenemos el siguiente formato:
\begin{itemize}
\item iptables {[}-t tabla{]} -X nombre\_cadena
\end{itemize}
Si seguimos con el ej anterior:
\begin{itemize}
\item iptables -X nueva\_cadena
\end{itemize}
Esto nos eliminara la cadena nueva\_cadena de la tabla filter (por
defecto) y las reglas contenidas en ella.


\subsection{Borrando cadenas en nftables}

En nftables por el contrario podemos borrar tanto cadenas base como
no base, solo necesitamos el nombre de la cadena, no nos importa si
es de un tipo o otro, tenemos el siguiente formato:
\begin{itemize}
\item nft delete chain nombre\_tabla nombre\_cadena
\end{itemize}
Y un ejemplo:
\begin{itemize}
\item nft delete chain filter output
\end{itemize}
El único requisito que nos impone nftables para poder borrar una cadena
es que no este vacía, si no, nos dará el siguiente error:

\includegraphics[scale=0.8]{pegado6}


\subsection{Vaciando cadenas en iptables}

En iptables podemos vaciar cadenas por defecto o personalizadas con
siguiente formato:


\subsection{Vaciando cadenas en nftables}

Para vaciar una cadena base o personalizada (nos da igual) basta con:
\begin{itemize}
\item nft flush chain nombre\_tabla nombre\_cadena
\end{itemize}
Y un ejemplo:
\begin{itemize}
\item nft flush chain filter input
\end{itemize}
Esto no vaciará las reglas que están en la cadena input 


\section{Configurando reglas}


\subsection{Añadiendo reglas en iptables}

En iptables podemos añadir reglas usando el siguiente formato:
\begin{itemize}
\item iptables {[}-t tabla{]} -A nombre\_cadena {[}-i -o --sport --dport
-p -j {]} {[}drop reject accept masquerade dnat snat{]}
\end{itemize}
Los parámetros están simplificados solo algunos de los mas usuales,
se pueden ver todo usando man iptables

Y un ejemplo:
\begin{itemize}
\item iptables -A INPUT -p tcp --dport 22 -j DROP
\end{itemize}
Estamos haciendo en esta ultima regla, que en la tabla filter (por
defecto) en la cadena INPUT, los paquetes que usen tcp por el puerto
22 (ssh) sean rechazados.


\subsection{Añadiendo reglas en nftables}

En nftables podemos ver a la hora de añadir reglas que es mucho mas
comprensible para el usuario. El formato para añadir una regla es:
\begin{itemize}
\item nft add rule nombre\_tabla nombre\_cadena {[}tcp upd ip{]} {[}daddr
saddr dport sport{]} {[}drop accept reject counter{]}
\end{itemize}
Los parámetros están simplificados, solo están algunos de los mas
usuales, se ver todas las opciones posibles en man nft

Si quisiéramos usar el ejemplo anterior de iptables, bastaría con
esto:
\begin{itemize}
\item nft add rule filter input tcp dport 22 drop
\end{itemize}
Podemos apreciar que nftables ofrece una interfaz mas clara en la
creación de reglas respecto de iptables.


\subsection{Eliminando reglas en iptables}

Para eliminar reglas en iptables podemos hacerlo listando las reglas
y viendo su numero, usando el parametro --line-number 
\begin{itemize}
\item iptables -L --line number
\end{itemize}
Teniendo como resultado esto:

\includegraphics{pegado7}

Una vez identificada la regla a eliminar, solamente necesitamos su
numero para eliminarla usando el parametro -D y la cadena donde esta
la regla, en el caso anterior:
\begin{itemize}
\item iptables -D INPUT 1
\end{itemize}
Para eliminar todas las reglas de una cadena (flush) podemos hacer
uso del parametro --flush indicando la cadena
\begin{itemize}
\item iptables --flush INPUT
\end{itemize}

\subsection{Eliminando reglas en nftables}

Para eliminar una regla en nftables lo podemos hacer de manera similar
a como lo hacemos en iptables, listando las reglas de una tabla especifica
(en nuestro caso filter) con el parámetro -a para que nos muestre
el numero de las reglas dentro de la tabla.
\begin{itemize}
\item nft list table filter -a
\end{itemize}
Dando como resultado esto:

\includegraphics{pegado8}

De esta manera, identificamos la regla que queremos eliminar mediante
su handle, para ejecutar a continuación la orden de eliminación con
el siguiente formato:
\begin{itemize}
\item nft delete rule nombre\_tabla nombre\_cadena handle numero\_de\_regla
\end{itemize}
Para nuestro caso:
\begin{itemize}
\item nft delete rule filter input handle 2.
\end{itemize}
Para borrar todas las reglas de una cadena (flush) 
\begin{itemize}
\item nft flush chain filter input
\end{itemize}

\section{Reemplazo atómico de reglas}


\subsection{Reemplazo atómico de reglas en iptables}

En iptables podemos hacer un cambio atómico de la reglas haciendo
uso de un fichero de texto donde tengamos almacenadas las reglas y
usando las utilidades iptables-save y iptables-restore.

Para guardar las reglas actuales:
\begin{itemize}
\item iptables-save {[}-c{]} {[}-t tabla{]} > archivo.txt
\end{itemize}
La opción c nos permite guardar también los contadores, y -t la tabla
(por defecto filter)

Una vez tenemos nuestro fichero archivo.txt podemos restaurarlo en
un futuro usando iptables-restore:
\begin{itemize}
\item iptables-restore {[}-c{]} {[}-n{]} < archivo.txt
\end{itemize}
La opción -c nos permite restablecer los contadores de bytes actuales
a los del fichero y la opción -n nos permite no reescribir las reglas
existentes en las tablas.


\subsubsection{Reemplazo atómico de reglas en nftables}

En nftables también es posible hacer un reemplazo atómico de reglas,
para ello podemos guardar las reglas actuales al estilo de iptables
guardándolas en un fichero de texto:
\begin{itemize}
\item nft list table nombre\_tabla > archivo.txt
\end{itemize}
Esto nos guardará las reglas presentes en la tabla indicando al fichero
archivo.txt. Cuando queramos restaurarlas simplemente hacemos:
\begin{itemize}
\item nft -f archivo.txt
\end{itemize}

\subsubsection{Uso de scripts en el cambio de reglas}

Dado que iptables y nftables usan un cambio atómico de reglas, no
se recomienda el uso de scripts que tengan una serie de ordenes para
hacer vaciado (flush) de reglas actuales, y acto seguido ingresen
las nuevas reglas dentro de iptables/nftables. De esta manera no se
está ejecutando un cambio atómico y por lo tanto cabe la posibilidad
de que en este cambio no atómico se puedan filtrar o filtrar paquetes
que no corresponden a nuestras reglas dentro del firewall. 


\section{Reporte de errores desde la linea de comandos}


\subsection{Reporte de errores desde la linea de comandos en iptables}

Cuando tenemos algún tipo de error en iptables ya sea una tabla/cadena
no encontrada o un error en el argumento introducido, iptables nos
reporta el error correspondiente, por ej:
\begin{itemize}
\item iptables -A CADENA\_ERRONEA DROP
\end{itemize}
Obtendremos la respuesta siguiente:

\includegraphics{pegado9}

Como vemos, reporta el error al argumento DROP que no a la cadena,
si quitamos el drop de la orden:

\includegraphics{pegado10}

Ahora si que reconoce la cadena errónea, por tanto puede dar lugar
a errores de compresión por parte del usuario, si además incluimos
varios fallos como: 
\begin{itemize}
\item iptables -t tabla\_falsa -A cadena\_falsa drop
\end{itemize}
Obtendremos:

\includegraphics{pegado11}

Como podemos observar, se han introducido 2 fallos pero muestra el
error en el drop, cuando los errores se encuentran en los nombres
de la tabla y cadena.

Esto pude ser confuso, veremos en el siguiente apartado que con nftables
esta solventado este comportamiento.


\subsection{Reporte de errores desde la linea de comandos en nftables}

En nftables también tenemos el soporte para los errores introducidos
desde la linea de comandos, si tomamos los mismo ejemplos del apartado
anterior tendríamos:
\begin{itemize}
\item nft add rule filter cadena\_falsa drop
\end{itemize}
Obtenemos lo siguiente:

\includegraphics{pegado12}

Como vemos, nos da un error general, si seguimos con el ejemplo anterior,
si quitamos el argumento drop:

\includegraphics{pegado14}

Nos señala que tenemos un error en la sintaxis y nos señala donde
esta el error, esto nos da una idea general del error mejor que en
iptables.

Seguimos con los ejemplos anteriores, si usamos una tabla falsa:

\includegraphics{pegado15}

Nos da un error general. COMPLETAR CON MAS INFORMACIÓN PREGUNTAR 


\section{Posibles acciones sobre los paquetes}


\subsection{Posibles acciones sobres los paquetes en iptables}


\subsubsection{Aceptando y rechazando paquetes}


\subsubsection{Saltando a cadenas}

En iptables podemos hacer el salto de paquetes a cadenas propias ,
por ejemplo, podemos crear previamente la cadena propia:
\begin{itemize}
\item iptables -N cadena\_propia
\end{itemize}
Una vez creada, podemos añadir reglas a esta cadena para después saltar
ella desde las cadenas base de la siguiente manera:
\begin{itemize}
\item iptables -A INPUT -p tcp -j cadena\_propia
\end{itemize}
Esto hará que los paquetes que vengan a nuestro sistema (cadena INPUT)
por el protocolo tcp serán direccionados hacia nuestra cadena propia.


\subsubsection{Log de paquetes}

En iptables podemos hacer un log de los paquetes que pasan por nuestro
firewall, basta con usar el parametro LOG, por ejemplo, si queremos
que nuestro sistema registre las conexiones ssh a nuestro sistema,
podemos usar:
\begin{itemize}
\item iptables -A INPUT -p tcp -m tcp --dport 22 -j LOG --log-prefix 'acceso
a ssh desde fuera ' --log-level 4
\end{itemize}
Donde:
\begin{itemize}
\item -p indica el protocolo 
\item -m indica que se marquen los paquetes con la marca tcp
\item -dport es el puerto destino 
\item -j la acción a realizar, en este caso el log del paquete
\item --log-prefix indica que se usará el prefijo entrecomillado
\item --log-level 4 activará syslog solo cuando el mensaje sea de tipo waring
(4)
\end{itemize}
De esta manera, si hacemos un intento de conexión a nuestro host por
ssh y vemos el archivo log (/var/log/syslog) veremos lo siguiente: 

\includegraphics{pegado16}

De esta manera podemos hacer un log preciso y monitorizar los accesos
a un servidor por ej, para servicios críticos en este cmo serian ssh,
mysql, rsync, ftp, etc. 


\subsubsection{NAT}

Para usar nat en iptables, necesitamos usar la tabla nat (por defecto
usamos filter) y antes que nada, ya que vamos a usar nat y por tanto
un comportamiento de router, debemos activar el bit de ip\_forward:
\begin{itemize}
\item echo 1 > /proc/sys/net/ipv4/ip\_forward\end{itemize}
\begin{enumerate}
\item SOURCE NAT
\end{enumerate}
Al usar nat en POSTROUTING estamos cambiando las direcciones origen
de los paquetes y estos, en el caso de que haya una comunicación con
algún host externo a nuestra red , los paquetes de respuesta deben
de llegar de nuevo al host original, así que debemos de volver a traducir
la dirección de destino hacia ese host, esto es automático en iptables.

Para ahcer SOURCE NAT (dinamico) con la red que normalmente usamos,
por ejemplo 192.168.1.0/24
\begin{itemize}
\item iptables -t nat -A POSTROUTING -s 192.168.3.0/24 -o eth0 -j MASQUERADE 
\end{itemize}
Donde:
\begin{itemize}
\item -A POSTROUTING añade la regla a la cadena POSTROUTING
\item -s indica la red en notación barra de la red que queremos hacer nat
\item -o eth0 la interfaz de salida de los paquetes
\item -j MASQUERADE la acción en este caso, indica que los paquetes de salida,
tendrán como ip de origen la de nuestro host (el que hace nat)\end{itemize}
\begin{enumerate}
\item DESTINATION NAT
\end{enumerate}
DESTINATION NAT se usa para modificar la dirección de destino de un
paquete que llega a nuestro sistema, por ejemplo, si estamos usando
nat, los dispositivos de nuestra red no son visibles, solo el host
que usa nat, es el visible desde internet, por tanto, si hay un servidor
web en nuestra, debemos de redirigir los paquetes que vengan por el
puerto 80 a este host, esto sería de la siguiente manera:
\begin{itemize}
\item iptables -t nat -A PREROUTING -p tcp --dport 80 -i eth0 -j DNAT --to
192.168.1.5
\end{itemize}
Donde:
\begin{itemize}
\item -A PREROUTING indica que se añadirá a la cadena PREROUTING
\item -p tcp el protocolo usado
\item --dport 80 el puerto de destino (destinantion port)
\item -i eth0 la interfaz de entrada el paquete 
\item -j DNAT --to la acción sobre el paquete, en este caso, cambiar el
destino a 192.168.1.5
\end{itemize}
De esta manera estamos alterando el paquete modificando su destino,
por estamos implementando dnat sobre nuestro firewall a los paquetes
que vengan por el puerto 80 desde fuera de nuestra red.


\subsubsection{Marcas sobre los paquetes}

Una funcionalidad de iptables es la posibilidad de marcar los paquetes
con un numero, se implementa usando el parametro --set-mark, por ej
podríamos marcar los paquetes que salgan por el puerto 80 para ver
que paginas visitan los usuarios de nuestra red:
\begin{itemize}
\item iptables -A PREROUTING -i eth0 -t mangle -p tcp --dport 80 -j MARK
--set-mark 1
\end{itemize}
Donde:
\begin{itemize}
\item -t mangle se refiere a la tabla mangle
\item -j MARK --ser-mark es la acción en este caso, marcar el paquete con
un 1 \end{itemize}
\begin{quotation}
Información obtenida de http://tldp.org/HOWTO/Adv-Routing-HOWTO/lartc.netfilter.html
\end{quotation}

\subsubsection{Queueing de paquetes}

Queue es una acción especial de iptables que pasa al paquete en una
cola destinada al procesamiento en espacio de usuario. Para que esto
sea útil, es necesario otros 2 componentes adicionales:
\begin{itemize}
\item Un controlador de cola, que lleva la mecánica real de paso de paquetes
entre el núcleo y el espacio de usuario.
\item Un proceso en espacio de usuario que recibe, posiblemente manipula,
y dicta veredicto sobre los paquetes.
\end{itemize}
Un ejemplo de como usar iptables para poner en cola los paquetes para
su proceso en espacio de usuario:
\begin{itemize}
\item modprobe iptable\_filter
\item modprobe ip\_queue (anticuado, ahora se debe usar nfnetlink\_queue)
\item iptables -A OUTPUT -p icmp -j QUEUE
\end{itemize}
Con esta regla, los paquetes ICMP generados de forma local (como los
que crea, digamos, ping), se pasan al módulo ip\_queue, que entonces
intenta pasarlos a una aplicación en espacio de usuario. Si no hay
una aplicación esperando por ellos, entonces se descartan.

Se puede comprobar el estado de ip\_queue mediante:
\begin{itemize}
\item /proc/net/ip\_queue (anticuado, sustituir ip\_queue por nfnetlink\_queue)\end{itemize}
\begin{quotation}
Nota: la información sobre el queue en iptables, se ha sacado (y actualizado)
en \url{http://www.netfilter.org/documentation/HOWTO/es/packet-filtering-HOWTO-7.html}
\end{quotation}

\subsection{Posibles acciones sobre los paquetes en nftables}


\subsubsection{Aceptando y rechazando paquetes}

Suponiendo que ya tengamos (como lo visto en los ejemplos anteriores)
una cadena y una tabla, para aceptar los paquetes de una cadena especifica
podemos hacer:
\begin{itemize}
\item nft add rule nombre\_tabla nombre\_cadena {[}operadores{]} accept
\end{itemize}
Y un ejemplo especifico, por ejemplo aceptar el uso de ftp (hacía
nuestro host):
\begin{itemize}
\item nft add rule filter input tcp dport 21 accept
\end{itemize}
Y lo tendríamos de esta manera:

\includegraphics{pegado17}

Para rechazar paquetes haríamos exactamente lo mismo pero cambiando
accet por drop:
\begin{itemize}
\item nft add rule nomber\_tabla nombre\_cadena {[}operadores{]} drop
\end{itemize}

\subsubsection{Saltando a cadenas}

De manera similar a iptables, también podemos tener cadenas personalizadas,
una vez tengamos creado alguna, podemos redirigir los paquetes que
venga por una cadena base (por ej input) a esta cadena para tratarlos
ahí. El formato a seguir es el siguiente:
\begin{itemize}
\item nft add rule nombre\_tabla nombre\_cadena {[}operadores{]} jump cadena\_personalizada
\end{itemize}
y un ejemplo:
\begin{itemize}
\item nft add rule filter input tcp dport 9999 jump prueba\_cadena\_personal
\end{itemize}
Nos quedaría lo siguiente:

\includegraphics{pegado18}


\subsubsection{Log de paquetes}

Para poder hacer un log de paquetes completo en nftables, necesitamos
un mayor o igual al 3.17, si se usa un kernel menor, se puede usar
el siguiente comando para permitir el log:
\begin{itemize}
\item modprobe ipt\_LOG
\end{itemize}
Para usar el log de paquetes hacemos:
\begin{itemize}
\item nft add rule nombre\_tabla nombre\_cadena {[}operadores{]} log
\end{itemize}
Y el mismo ejemplo que usamos en iptables para el loggin de conexiones
ssh
\begin{itemize}
\item nft add rule filter input tcp dport 22 ct state new log prefix \textbackslash{}\textquotedbl{}Nueva
conexion ssh \textbackslash{}\textquotedbl{} accept
\end{itemize}
Donde:
\begin{itemize}
\item ct state para indicar el estado en el que debe de estar la conexion
(new, established, related, etc)
\item new el estado propiamente
\item log prefix Le estamos indicando que en el log se pondra el prefijo
que Nueva conexion ssh
\end{itemize}
Si miramos el log en /var/log/syslog al hacer una conexión ssh a nuestro
propio sistema tendremos el siguiente resultado:

\includegraphics{pegado19}

Esta captura está recortada.


\subsubsection{NAT}

Como en iptables, nftables también puede hacer nat y de manera mas
simple por su sintaxis, de nuevo, distinguimos entre SNAT (source
nat) y DNAT (destination nat)
\begin{enumerate}
\item SNAT
\end{enumerate}
Para hacer SNAT y querer usar nuestro host como si un router se tratara,
debemos de activar el bit de ip\_forward como hicimos en el ejemplo
de iptables:
\begin{itemize}
\item echo 1 > /proc/sys/net/ipv4/ip\_forward
\end{itemize}
Una vez hecho esto podemos empezar a establecer SNAT con los siguientes
pasos:
\begin{itemize}
\item nft add table nat
\item nft add chain nat prerouting \{ type nat hook prerouting priority
0 \textbackslash{}; \}
\item nft add chain nat postrouting \{ type nat hook postrouting priority
0 \textbackslash{}; \}
\end{itemize}
Con esto hemos creado la tabla nat con las cadenas base prerouting
y postrouting (creamos las 2 para el ejemplo de snat y dnat, aunque
no es necesario si solo se implementa uno de los casos). 

Siguiendo el ejemplo que hicimos en iptables, para hacer nat (snat
o dnat) de una red seguimos este formato:
\begin{itemize}
\item nft add rule nat {[}postrouing| prerouting{]} ip {[}saddr|daddr{]}
{[}red notación barra|ip {]} oif {[}interfaz de red{]} {[}snat|ndat{]}
{[}ip{]}
\end{itemize}
Y el ejemplo practico de hacer snat 
\begin{itemize}
\item nft add rule nat postrouting ip saddr 192.168.1.0/24 oif wlan0 snat
8.8.8.8
\end{itemize}
Donde:
\begin{itemize}
\item saddr indica la ip o la red de la que proceden los paquetes
\item oif define la interfaz por la que se recogen los paquetes, en este
caso wlan0
\item snat indica la ip que tendrán los paquetes como origen al salir de
la red
\end{itemize}
De esta manera, si nuestro host es un router que esta conectado a
la red indicada los host que tengan configurada como gateway nuestro
host, cambiará el la ip de origen a 8.8.8.8 de los paquetes que salgan
de nuestra red.
\begin{enumerate}
\item DNAT
\end{enumerate}
Para hacer dnat, si tenemos algún servidor web en nuestra red y queremos
que sea accesible desde el exterior si se esta usando nat, debemos
de seguir el mismo formato que en el anterior caso, y bastaría con
lo siguiente:
\begin{itemize}
\item nft add rule nat prerouting iif wlan0 tcp dport 80 dnat 192.168.1.3
\end{itemize}
Donde:
\begin{itemize}
\item iif indica la interfaz por donde vendrán los paquetes, en este caso
wlan0
\item tcp dport 80 el puerto y protocolo por donde vendrán los paquetes.
\item dnat hace el traslado de ip destino, cambiaría la ip de nuestro host
(el router) por 192.168.1.3 (la del servidor web)
\end{itemize}
De esta manera, se podrá acceder al servidor web desde el exterior
de nuestra red. Cabe decir que nftables nos permite hacer también
un set de puertos para un mismo destino, por ej:
\begin{itemize}
\item nft add rule nat prerouting iif wlan0 tcp dport \{80, 443\} dnat 192.168.1.3
\end{itemize}
De esta manera estamos redirigiendo tantos los paquetes que vengan
por el puerto 80 y el 443. 
\begin{enumerate}
\item NAT FLAGS 
\end{enumerate}
Como extra a iptables, nftables implementa a partir del kernel 3.18
el mapeo de puertos aleatorios, además de incluir también que se mantengan
estos números de puertos para cada conexión. Los parámetros son:
\begin{itemize}
\item random: Puertos origen aleatorios.
\item random-fully: Puertos (origen y destino) aleatorios.
\item persistent: Mantiene los puertos para el origen y destino para cada
conexión.
\end{itemize}
Para el ejemplo anterior, lo usaríamos de la siguiente manera:
\begin{itemize}
\item nft add rule nat postrouting masquerade random,persistent
\item nft add rule nat postrouting ip saddr 192.168.1.0/24 oif wlan0 snat
8.8.8.8 random-fully\end{itemize}
\begin{quotation}
Nota: Los ejemplos sobre nat han sido inspirados según el manual de
nftables disponible en: \url{http://wiki.nftables.org/wiki-nftables/index.php/Performing_Network_Address_Translation_%28NAT%29}
\end{quotation}

\subsection{Marcas sobre los paquetes}

Como en iptables, nftables permite marcar los paquetes con números
usando la opción set mark, para repetir el ejemplo usado en el apartado
de iptables en la cual marcamos los paquetes que sean por el puerto
80 para saber que paginas web se visitaban en nuestra red , debemos
de seguir el siguiente formato:
\begin{itemize}
\item nft add rule filter output tcp dport 80 mark set 9999 
\end{itemize}

\subsection{Queueing de paquetes}

Como en iptables, podemos hacer queueing de paquetes en nftables para
encolarlos hacia el espacio de usuario, esta característica esta disponible
desde el kernel 3.14 y es necesario tener la librería libnetfilter\_queue
(disponible en algunos repositorios oficiales o en el git \url{https://git.netfilter.org/libnetfilter_queue/}

Para hacerlo seguimos el siguiente formato:
\begin{itemize}
\item nft add nombre\_tabla nombre\_cadena {[}operadores{]} queue {[} num
valor{]}
\end{itemize}
Si no añadimos un numero, el valor por defecto sera 0.

Ejemplo practico:
\begin{itemize}
\item nft add filter input counter queue num 3
\end{itemize}
Con esto ya estamos marcando los paquetes que vayan a nuestro host,
si generamos un poco de trafico, podemos verlo en accion:

Debemos de tener en cuenta de que si no hay ningún programa escuchando
a queue, los paquetes serán rechazados. COMPLETAR.


\section{Estructuras de datos avanzadas en nftables}

Nftables permite el uso de estructuras de datos avanzadas para la
mejora de rendimiento en la clasificación de paquetes, esta es una
característica no disponible en iptables, esto incluye:
\begin{itemize}
\item Sets
\item Diccionarios
\item Intervalos 
\item Mapas
\end{itemize}

\subsection{Sets}

En nftables viene incluida una infraestructura genérica de conjuntos
que permite usar todos selectores soportados para construir sets.
Con esta infraestructura es posible representar diccionarios y mapas.


\subsubsection{Sets anonimos }

Los sets anonimos son aquellos que son:
\begin{itemize}
\item Los atados a una reglas, si una regla es eliminada, el set también
lo es.
\item Los que no tienen un nombre propio, el kernel les asigna uno automáticamente
\item No actualizables, no se pueden añadir o quitar elementos cuando son
atados a una regla.
\end{itemize}
La siguiente regla representa un set anonimo:
\begin{itemize}
\item nft add rule filter output tcp dport \{ 80, 443 \} counter
\end{itemize}
Donde \{80,443 \} representa al set anonimo.


\subsubsection{Named sets}

Se pueden crean set con un nombre asociado y añadirlos a una tabla
ya creada por ej:
\begin{itemize}
\item nft add set nombre\_tabla nombre\_set \{type {[}ipv4\_addr | ipv6\_addr
| ether\_addr | inet\_proto | inet\_service | mark{]}\}
\end{itemize}
Y un ejemplo:
\begin{itemize}
\item nft add set filter ip\_list \{ type ipv4\_addr \textbackslash{}; \}
\end{itemize}
De esta manera hemos añadido un set de direcciones ipv4 a la tabla
filter:

\includegraphics{pegado20}

Ahora podemos añadir elementos de manera única:
\begin{itemize}
\item nft add element filter ip\_list \{192.168.1.5\}
\end{itemize}
O usando un set anonimo:
\begin{itemize}
\item nft add element filter ip\_list \{ 192.168.1.6, 192.168.1.7\}
\end{itemize}
Si comprobamos:

\includegraphics{pegado21}

Ahora podemos enlazar este set en una regla, por ejemplo añadir un
contador a los paquetes que son tienen como destino las ips del set:
\begin{itemize}
\item nft add rule filter input ip daddr @ip\_list counter 
\end{itemize}
Mirando la tabla, vemos enlazado el set en la cadena input:

\includegraphics{pegado22}

Además a los named set, se pueden añadir o quitar elementos, cosa
que no podemos hacer en los set anónimos.

Para comprobar la diferencia real con iptables, podemos ver este ej
hecho por Eric leblond en este articulo \href{https://home.regit.org/2014/01/why-you-will-love-nftables/}{why you love nftables}

Tenemos la siguientes acciones en nftables:
\begin{itemize}
\item ip6tables -A INPUT -p tcp -m multiport --dports 22,80,443 -j ACCEPT 
\item ip6tables -A INPUT -p icmpv6 --icmpv6-type neighbor-solicitation -j
ACCEPT 
\item ip6tables -A INPUT -p icmpv6 --icmpv6-type echo-request -j ACCEPT
\item ip6tables -A INPUT -p icmpv6 --icmpv6-type router-advertisement -j
ACCEPT
\item ip6tables -A INPUT -p icmpv6 --icmpv6-type neighbor-advertisement
-j ACCEPT
\end{itemize}
Y se pueden expresar en nftables en solo 2 operaciones:
\begin{itemize}
\item nft add rule ip6 filter input tcp dport \{telnet, http, https\} accept
\item nft add rule ip6 filter input icmpv6 type \{ nd-neighbor-solicit,
echo-request, nd-router-advert, nd-neighbor-advert \} accept
\end{itemize}
¿Se aprecia la diferencia? 


\subsubsection{Listando sets}

Usando el siguiente formato se pueden listar sets:
\begin{itemize}
\item nft list set nombre\_tabla nombre\_set
\end{itemize}

\subsection{Diccionarios }

Los diccionarios o verdict maps es una funcionalidad destacable en
nftables. Permiten relacionar una acción a un elemento. Internamente
usan un set generico.


\subsubsection{Diccionarios anónimos}

Suponiendo que tenemos varias cadena personalizadas podemos ver como
podemos podemos crear en una linea varias acciones, el formato para
hacer un diccionario anónimo es:
\begin{itemize}
\item nft add rule nombre\_tabla nombre\_cadena ip protocol vmap \{ {[}protocolo1
jump cadena1{]},{[}proto2 jump cadena2{]} ...\}
\end{itemize}
De esta manera estamos creando en una linea n saltos que serán en
las cadenas personalizadas según su protocolo

Un ejemplo sacado la wiki de \href{http://wiki.nftables.org/wiki-nftables/index.php/Dictionaries}{nftables}:
\begin{itemize}
\item nft add rule ip filter input ip protocol vmap \{ tcp : jump tcp-chain,
udp : jump udp-chain , icmp : jump icmp-chain \}
\end{itemize}
En este ejemplo se crea el mapa y se asocian los protocolos tcp, udp
y icmp a distintas cadenas.


\subsubsection{Diccionarios con nombre}

Podemos crear diccionarios con nombre siguiendo el formato siguiente:
\begin{itemize}
\item nft add map nombre\_tabla nombre\_diccionario \{ type {[}tipo{]} :
verdict\textbackslash{}; \}
\end{itemize}
Un ejemplo:
\begin{itemize}
\item nft add map filter diccionario \{ type ipv4\_addr : verdict\textbackslash{};
\}
\end{itemize}
Y podemos añadir elementos del tipo del que sea el diccionario:
\begin{itemize}
\item nft add element filter diccionario \{ 192.168.1.3 : accept, 192.168.1.5
drop \}
\end{itemize}
Una vez hecho esto, podemos usar el diccionario las acciones asociadas
a sus elementos:
\begin{itemize}
\item nft add rule filter ouput daddr vmap @diccionario
\end{itemize}
Realmente en esta regla se estaría provocando lo siguiente:
\begin{itemize}
\item nft add rule filter output daddr 192.168.1.3 accept
\item nft add rule filter output daddr 192.168.1.5 drop
\end{itemize}

\subsubsection{Intervalos }

Nftables permite el uso de expresiones con intervalos, los rangos
se leen como valor\_minimo-valor\_maximo, los intervalos sirven tanto
para ips como para puertos, algunos ejemplo:
\begin{itemize}
\item nft add rule filter output ip daddr 8.8.8.4-8.8.8.8 drop
\item nft add rule filter output tcp ports 50-60 drop
\end{itemize}
COMPLETAR SON SETS Y DICCIONARIOS


\subsubsection{Mapas}


\section{Ejemplo de uso practico con nftables}

Para terminar podemos exponer un uso practico de un practico de nftables
en una red, el problema es:
\begin{enumerate}
\item Tenemos una empresa, en la cual tenemos 3 subredes: 192.168.1.0/24,
192.168.2.0/24 y 192.168.3.0/24
\item Para la red 192.168.1.0/24 tenemos los requisitos siguientes:

\begin{enumerate}
\item Esta compuesta por 2 servidores, uno web (192.168.1.2)y otro ftp (192.168.12),
en los cuales se debe implementar nat
\item Los servidores SOLO deben de escuchar/responder peticiones, jamas
hacerlas hacia el exterior
\end{enumerate}
\item Para red 192.168.2.0/24 tenemos los siguientes requisitos:

\begin{enumerate}
\item Esta formada por trabajadores de la empresa, por tanto pueden acceder
hacia el exterior
\item No se permite el uso de ciertas paginas web (facebook y twitter)
\item No pueden recibir peticiones del exterior.
\end{enumerate}
\item Para la red 192.168.3.0/24 tenemos los siguientes requisitos:

\begin{enumerate}
\item Esta formada por equipos en pruebas, por tanto solo pueden tener acceso
entre ellos y nunca pueden recibir peticiones desde el exterior ni
tampoco acceder a este. 
\end{enumerate}
\end{enumerate}
Suponiendo que tenemos un equipo que hace router, y este esta conectado
a las 3 redes y a internet, podemos configurar nftables de la siguiente
manera para solventar los requisitos siguientes:

Para la red 192.168.1.0/24:
\begin{itemize}
\item nft add rule nat prerouting ip daddr 192.168.1.0/24 tcp dport 80 dnat
192.168.1.2
\item nft add rule nat prerouting ip daddr 192.168.1.0/24 tcp dport 21 dnat
192.168.1.3
\item nft add rule filter input ip saddr 192.168.1.0/24 ct state new drop 
\item nft add rule filter input ip saddr 192.168.1.0/24 ct state established
accept 
\end{itemize}
Para la red 192.168.2.0/24:
\begin{itemize}
\item nft add rule filter input ip saddr 192.168.2.0/24 ct state new ct
state established accept {*}
\item nft add rule filter input ip saddr 192.168.2.0/24 ct state establised
accept {*}
\item nft add rule filter input ip daddr 192.168.2.0/24 ct state new drop
\item nft add rule filter input ip saddr 192.168.2.0/24 ip daddr 8.8.8.8
drop (suponiendo facebook.es -> 8.8.8.8)
\item nft add rule filter input ip saddr 192.168.1.0/24 ip daddr 8.8.8.4
drop (suponiendo twitter.es -> 8.8.8.4)
\end{itemize}
Para la red 192.168.3.0/24
\begin{itemize}
\item nft add rule filter input ip saddr 192.168.3.0/24 drop
\item nft add rule filter input ip daddr 192.168.3.0/24 drop\end{itemize}

\end{document}
